---
export interface Props {
  items: Array<{
    title: string;
    description: string;
    number: number;
    tags: string[];
    photoOptions?: {
      photos: Array<string | { src: string; alt: string }>;
      appearance?: 'before' | 'after' | 'inline';
    };
    links?: Array<{
      text: string;
      link: string;
      target?: string;
    }>;
  }>;
  showClearFilters?: boolean;
}

// Helper to normalize photo to src/alt object
function normalizePhoto(photo: string | { src: string; alt: string }, fallbackAlt: string): { src: string; alt: string } {
  if (typeof photo === 'string') {
    return { src: photo, alt: fallbackAlt };
  }
  return photo;
}

const { items, showClearFilters = false } = Astro.props;
const sortedItems = items.sort((a, b) => a.number - b.number);

// Get filter from URL query params (supports multiple tags comma-separated)
const activeTagsParam = Astro.url.searchParams.get('tags') || null;
const activeTags = activeTagsParam ? activeTagsParam.split(',').filter(t => t.trim()) : [];
const filteredItems = activeTags.length > 0
  ? sortedItems.filter(item => activeTags.every(tag => item.tags.includes(tag)))
  : sortedItems;

// Get current URL without query params for clear filters link
const currentPath = Astro.url.pathname;
---

<div class="max-w-6xl mx-auto px-3 mb-5">
  {showClearFilters && (
    <div class="mb-4 mt-4">
      <a href={currentPath} id="page-items-clear-filters" class={`px-5 py-2 text-white rounded-full text-sm transition-colors cursor-pointer inline-block ${activeTags.length > 0 ? '' : 'hidden'}`} style="background-color: #1a4d2e;">
        Clear filters
      </a>
    </div>
  )}
  
  
  {filteredItems.map((item) => (
    <section class="page-item text-xl pb-7" data-tags={item.tags.join(',')}>
      <div>
        {item.photoOptions && item.photoOptions.photos && item.photoOptions.photos.length > 0 && item.photoOptions.appearance === 'before' && (
          <div class="pb-5">
            <div class="flex flex-wrap gap-4">
              {item.photoOptions.photos.map((photo) => {
                const p = normalizePhoto(photo, item.title);
                return <img src={p.src} alt={p.alt} class="rounded-xl w-full max-w-md h-auto object-cover" loading="lazy" />;
              })}
            </div>
          </div>
        )}
        <h2 class="text-3xl mb-2" style="font-family: 'Libre Baskerville', serif;">
          <span class="font-normal mr-2"><span class="text-logoDarkGreen">{item.number}</span><span class="text-logoLightGreen ml-0.5" style="font-size: 2.1rem;">.</span></span>
          {item.title}
          <span class="color-pink ml-1"><b>.</b></span>
        </h2>
        <div class="pb-5">
          {item.description}
        </div>
        {item.links && item.links.length > 0 && (
          <div class="pb-5">
            <div class="flex flex-wrap gap-4">
              {item.links.map((link) => (
                <a href={link.link} target={link.target || '_blank'} rel={link.target === '_blank' ? 'noopener noreferrer' : undefined} class="page-item-link text-logoDarkGreen underline">
                  {link.text}
                </a>
              ))}
            </div>
          </div>
        )}
        {item.photoOptions && item.photoOptions.photos && item.photoOptions.photos.length > 0 && item.photoOptions.appearance === 'inline' && (
          <div class="pb-5">
            <div class="flex flex-wrap gap-4">
              {item.photoOptions.photos.map((photo) => {
                const p = normalizePhoto(photo, item.title);
                return <img src={p.src} alt={p.alt} class="rounded-xl w-full max-w-md h-auto object-cover" loading="lazy" />;
              })}
            </div>
          </div>
        )}
        <div class="pb-5">
          <div class="flex flex-wrap gap-2">
            {item.tags.map((tag) => {
              const isActive = activeTags.includes(tag);
              // Build URL: if tag is active, remove it; otherwise add it
              let tagUrl;
              if (isActive) {
                const newTags = activeTags.filter(t => t !== tag);
                tagUrl = newTags.length > 0 ? `${currentPath}?tags=${newTags.join(',')}` : currentPath;
              } else {
                const newTags = [...activeTags, tag];
                tagUrl = `${currentPath}?tags=${newTags.join(',')}`;
              }
              return (
                <a href={tagUrl} class="page-item-tag px-5 py-2 text-white rounded-full text-sm cursor-pointer transition-colors font-normal no-underline" style={`background-color: ${isActive ? '#3CB371' : '#1a4d2e'};`} data-tag={tag}>
                  #{tag}
                </a>
              );
            })}
          </div>
        </div>
        {item.photoOptions && item.photoOptions.photos && item.photoOptions.photos.length > 0 && (item.photoOptions.appearance === 'after' || !item.photoOptions.appearance) && (
          <div class="pb-5">
            <div class="flex flex-wrap gap-4">
              {item.photoOptions.photos.map((photo) => {
                const p = normalizePhoto(photo, item.title);
                return <img src={p.src} alt={p.alt} class="rounded-xl w-full max-w-md h-auto object-cover" loading="lazy" />;
              })}
            </div>
          </div>
        )}
      </div>
    </section>
  ))}
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const tagLinks = document.querySelectorAll('.page-item-tag');
    const clickableFilterTags = document.querySelectorAll('.clickable-filter-tag');
    const pageItems = document.querySelectorAll('.page-item');
    
    // Helper function to get active tags from URL
    function getActiveTags() {
      const currentUrl = new URL(window.location.href);
      const activeTagsParam = currentUrl.searchParams.get('tags');
      return activeTagsParam ? activeTagsParam.split(',').filter(t => t.trim()) : [];
    }
    
    // Helper function to update URL with active tags
    function updateUrlWithTags(activeTags) {
      const currentUrl = new URL(window.location.href);
      if (activeTags.length > 0) {
        currentUrl.searchParams.set('tags', activeTags.join(','));
      } else {
        currentUrl.searchParams.delete('tags');
      }
      window.history.pushState({}, '', currentUrl.toString());
    }
    
    // Helper function to filter items based on active tags
    function filterItems(activeTags) {
      pageItems.forEach(item => {
        const itemTags = item.getAttribute('data-tags');
        const itemTagsArray = itemTags ? itemTags.split(',').map(t => t.trim()) : [];
        
        if (activeTags.length === 0) {
          // Show all items if no filters
          item.style.display = '';
        } else {
          // Show item only if it has ALL active tags (AND logic)
          const hasAllTags = activeTags.every(tag => itemTagsArray.includes(tag));
          item.style.display = hasAllTags ? '' : 'none';
        }
      });
    }
    
    // Helper function to update all tag highlights
    function updateTagHighlights(activeTags) {
      // Update page-item tags
      tagLinks.forEach(t => {
        const tagValue = t.getAttribute('data-tag');
        if (activeTags.includes(tagValue)) {
          t.style.backgroundColor = '#3CB371';
        } else {
          t.style.backgroundColor = '#1a4d2e';
        }
      });
      
      // Update clickable filter tags
      clickableFilterTags.forEach(t => {
        const tagValue = t.getAttribute('data-tag');
        if (activeTags.includes(tagValue)) {
          t.style.backgroundColor = '#3CB371';
        } else {
          t.style.backgroundColor = '#1a4d2e';
        }
      });
    }
    
    // Helper function to show/hide place description based on single place tag selection
    function updatePlaceDescription(activeTags) {
      const placeDescriptions = document.querySelectorAll('.place-description');
      if (placeDescriptions.length === 0) return;
      
      const placeKeys = Array.from(placeDescriptions).map(el => el.dataset.place);
      const activePlaceTags = activeTags.filter(tag => placeKeys.includes(tag));
      const activePlace = activePlaceTags.length === 1 ? activePlaceTags[0] : null;
      
      placeDescriptions.forEach(el => {
        if (el.dataset.place === activePlace) {
          el.classList.remove('hidden');
        } else {
          el.classList.add('hidden');
        }
      });
    }
    
    // Helper function to show/hide distance filters based on activity selection
    function updateDistanceFiltersVisibility(activeTags) {
      const distanceSection = document.getElementById('distance-filters-section');
      if (!distanceSection) return;
      
      const activityTags = ['biking', 'hiking', 'paddling', 'climbing'];
      const hasActivity = activityTags.some(activity => activeTags.includes(activity));
      
      if (hasActivity) {
        // Get all distance tags available in items that match current filters
        const distanceTags = ['1-to-2-miles', '3-to-5-miles', '5-to-10-miles', '10-to-20-miles', '20-plus-miles'];
        const availableDistanceTags = new Set();
        
        pageItems.forEach(item => {
          const itemTags = item.getAttribute('data-tags');
          if (!itemTags) return;
          
          const itemTagsArray = itemTags.split(',').map(t => t.trim());
          
          // Check if item matches current filters (excluding distance tags)
          const nonDistanceTags = activeTags.filter(tag => !distanceTags.includes(tag));
          if (nonDistanceTags.length === 0 || nonDistanceTags.every(tag => itemTagsArray.includes(tag))) {
            // Item matches, add its distance tags to available set
            itemTagsArray.forEach(tag => {
              if (distanceTags.includes(tag)) {
                availableDistanceTags.add(tag);
              }
            });
          }
        });
        
        // Only show distance section if there are distance tags available
        if (availableDistanceTags.size === 0) {
          distanceSection.style.display = 'none';
          return;
        }
        
        // Show distance filters section
        distanceSection.style.display = '';
        
        // Show/hide individual distance filter tags
        distanceSection.querySelectorAll('.clickable-filter-tag').forEach(tagEl => {
          const tagValue = tagEl.getAttribute('data-tag');
          if (availableDistanceTags.has(tagValue)) {
            tagEl.style.display = '';
          } else {
            tagEl.style.display = 'none';
          }
        });
      } else {
        // Hide distance filters section
        distanceSection.style.display = 'none';
      }
    }
    
    // Helper function to toggle a tag
    function toggleTag(clickedTag) {
      let activeTags = getActiveTags();
      const activityTags = ['biking', 'hiking', 'paddling', 'climbing'];
      const distanceTags = ['1-to-2-miles', '3-to-5-miles', '5-to-10-miles', '10-to-20-miles', '20-plus-miles'];
      
      if (activeTags.includes(clickedTag)) {
        // Remove tag if already active
        activeTags = activeTags.filter(tag => tag !== clickedTag);
        
        // If removing an activity tag, also remove all distance tags
        if (activityTags.includes(clickedTag)) {
          activeTags = activeTags.filter(tag => !distanceTags.includes(tag));
        }
      } else {
        // Add tag if not active
        activeTags.push(clickedTag);
      }
      
      // Update URL
      updateUrlWithTags(activeTags);
      
      // Filter items
      filterItems(activeTags);
      
      // Update highlights
      updateTagHighlights(activeTags);
      
      // Update distance filters visibility
      updateDistanceFiltersVisibility(activeTags);
      
      // Update place description visibility
      updatePlaceDescription(activeTags);
      
      // Update clear filters button
      const clearBtn = document.getElementById('page-items-clear-filters');
      if (clearBtn) {
        if (activeTags.length > 0) {
          clearBtn.classList.remove('hidden');
        } else {
          clearBtn.classList.add('hidden');
        }
      }
    }
    
    // Highlight tags on initial load
    const initialActiveTags = getActiveTags();
    if (initialActiveTags.length > 0) {
      updateTagHighlights(initialActiveTags);
      filterItems(initialActiveTags);
    }
    updateDistanceFiltersVisibility(initialActiveTags);
    updatePlaceDescription(initialActiveTags);
    
    // Handle page-item tag clicks
    tagLinks.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const tag = this.getAttribute('data-tag');
        toggleTag(tag);
      });
    });
    
    // Handle clickable filter tag clicks
    clickableFilterTags.forEach(link => {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const tag = this.getAttribute('data-tag');
        toggleTag(tag);
      });
    });
    
    // Clear filters button handler
    const clearBtn = document.getElementById('page-items-clear-filters');
    if (clearBtn) {
      clearBtn.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Clear all tags
        updateUrlWithTags([]);
        
        // Show all items
        filterItems([]);
        
        // Reset all tag highlights
        updateTagHighlights([]);
        
        // Hide distance filters section
        updateDistanceFiltersVisibility([]);
        
        // Hide place description
        updatePlaceDescription([]);
        
        // Hide clear button
        clearBtn.classList.add('hidden');
      });
    }
  });
</script>

<style>
  .page-item-tag,
  .clickable-filter-tag {
    color: white !important;
    -webkit-tap-highlight-color: transparent;
  }
  .page-item-tag:hover,
  .clickable-filter-tag:hover,
  .page-item-tag:active,
  .clickable-filter-tag:active,
  .page-item-tag:focus,
  .clickable-filter-tag:focus {
    background-color: #3CB371 !important;
    color: white !important;
  }
  .page-item-link {
    text-decoration-color: #3CB371;
  }
</style>
